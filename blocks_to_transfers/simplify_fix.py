"""
Before exporting transfers, we use a very flexible graph structure to model the interactions
between trips, verify conditions and transform the representation.
"""
import collections
import enum
from . import service_days, simplify_graph
from .logs import Warn


def simplify(gtfs, services, generated_transfers):
    print('Merging with predefined transfers and validating against spec')
    graph = simplify_graph.Graph(gtfs, services)
    primary_nodes = {}

    import_predefined_transfers(graph, primary_nodes)
    delete_impossible_edges(graph, print_warnings=True)

    import_generated_transfers(graph, primary_nodes, generated_transfers)
    split_ordered_alternatives(graph)
    delete_impossible_edges(graph, print_warnings=False)

    del primary_nodes
    validate(graph)

    return graph


def import_generated_transfers(graph, primary_nodes, generated_transfers):
    for transfer in generated_transfers:
        from_node = graph.make_primary_node(primary_nodes,
                                            transfer.from_trip_id)
        if from_node.out_edges.has_predefined_transfers():
            # from_node already has some predefined transfer out edges
            continue

        to_node = graph.make_primary_node(primary_nodes, transfer.to_trip_id)
        if to_node.in_edges.has_predefined_transfers():
            # to_node already has some predefined transfer in edges
            continue

        graph.add_edge(from_node, to_node, transfer)


def split_ordered_alternatives(graph):
    """
    The spec requires all from_trip_ids of a certain to_trip_id, and all to_trip_ids of a certain from_trip_id,
    to form 'disjoint cases' (either matching another case exactly, or disjoint of all cases.)

    For transfers automatically generated by conversion from blocks, there is a rule we can use to fix
    cases that aren't disjoint: greedily take as many days as possible from each transfer in order of wait_time.

    (For user-defined transfers, there's no way to know if the conflicting 
    trips are alternatives, or vehicle joins/splits, or both.)

    This step splits primary nodes into separate nodes for each cases. For convenience of traversal over newly created
    nodes, we use BFS but any traversal order is valid. This step repeats roughly the same calculation as convert_blocks,
    but nodes can be split several times in a row in this operation.
    """
    queue = collections.deque(graph.nodes)
    visited = set()
    while queue:
        from_node = queue.popleft()
        if from_node in visited:
            continue

        visited.add(from_node)

        days_running = from_node.days
        days_matched = service_days.DaySet()

        for to_node, transfer in from_node.out_edges.generated_by_rank():
            to_days_in_frame = graph.services.days_in_from_frame(
                from_node.trip, to_node.trip, to_node.days)
            days_when_best = to_days_in_frame.intersection(days_running)

            # Note: empty sets are always disjoint of any other set (including other empty sets)
            if not days_when_best.isdisjoint(days_matched):
                days_when_best = days_when_best.difference(days_matched)
                # Always smaller than the original set after this step, as the
                # two sets weren't disjoint.
                to_node_split = graph.split(from_node, to_node, days_when_best)
                if to_node_split:
                    queue.append(to_node_split)

            days_matched = days_matched.union(days_when_best)
            queue.append(to_node)


def import_predefined_transfers(graph, primary_nodes):
    for from_trip_id, transfers in graph.gtfs.transfers.items():
        if not from_trip_id:
            continue  # route-to-route or stop-to-stop transfers and such

        for transfer in transfers:
            if transfer.from_trip_id == transfer.to_trip_id:
                Warn(f'Removed self-transfer for trip {transfer.from_trip_id}'
                    ).print()
                continue

            if not transfer.is_continuation:
                # Provides walk time between two trips using separate vehicles.
                continue

            graph.make_primary_edge(primary_nodes, transfer)


def delete_impossible_edges(graph, print_warnings):
    """
    Delete any edges that can never be crossed, because there are no common 
    days of service between from_node and to_node. 

    We use it silently to clean up after transforms of converted blocks,
    and with warnings to help users fix predefined transfers.txt entries
    that are not useful.
    """

    for from_node in graph.nodes:
        for to_node, transfer in list(from_node.out_edges.items()):
            if not to_node.has_trip():  # sink_node is permanent
                continue

            to_node_days = graph.services.days_in_from_frame(
                from_node.trip, to_node.trip, to_node.days)
            match_days = to_node_days.intersection(from_node.days)
            if not match_days:
                if print_warnings:
                    Warn(
                        f'Removing {from_node.trip_id} -> {to_node.trip_id} as it does not occur on any days of service.'
                    ).print()
                graph.del_edge(from_node, to_node)


def validate(graph):
    """
    The spec requires all from_trip_ids of a certain to_trip_id, and all 
    to_trip_ids of a certain from_trip_id, to form 'disjoint cases' (either 
    matching another case exactly, or disjoint of all cases.) This step deletes
    non-conformant edges.

    For any node, if there is no out-edge continuation on a certain day, it is 
    associated with the imaginary 'start node'. Similarily, if there are no
    in-edges for a certain day, it will be associated with the 'terminal node'.
    """
    for node in graph.nodes:
        validate_distinct_cases(graph, simplify_graph.EdgeType.IN, node,
                                node.in_edges)
        validate_distinct_cases(graph, simplify_graph.EdgeType.OUT, node,
                                node.out_edges)


def validate_distinct_cases(graph, edge_type, node, neighbours):
    union_cases = service_days.DaySet()
    distinct_cases = set()
    is_composite = False

    for neighbour, transfer in list(neighbours.items()):
        if not neighbour.has_trip():
            continue  # Source or sink node (always empty at this point)

        if edge_type is simplify_graph.EdgeType.OUT:
            match_days = graph.services.days_in_from_frame(
                node.trip, neighbour.trip, neighbour.days)
        else:
            match_days = graph.services.days_in_to_frame(
                neighbour.trip, node.trip, neighbour.days)

        if match_days in distinct_cases:
            if not transfer.is_generated:
                # Only transfers in transfers.txt will ever represent join/split
                # If this case is encountered from converted blocks, it means
                # the source data was invalid, and we need to erase this
                # transfer.
                node.composite = True
                continue

        if match_days.isdisjoint(union_cases):
            union_cases = union_cases.union(match_days)
            distinct_cases.add(match_days)
            continue

        conflict_days = ', '.join(
            str(date) for date in graph.services.to_dates(
                match_days.intersection(union_cases)))
        conflict_days = graph.services.bdates(
            match_days.intersection(union_cases))
        other_trips = ', '.join(other_node.trip_id
                                for other_node in neighbours
                                if other_node is not neighbour)

        if edge_type is simplify_graph.EdgeType.OUT:
            description = f"out edge of {node.trip_id} -> {neighbour.trip_id}"
            graph.del_edge(node, neighbour)
        else:
            description = f"{neighbour.trip_id} -> in edge of {node.trip_id}"
            graph.del_edge(neighbour, node)

        Warn(f'''
            Removing {description} as it does not represent a disjoint case.
                Conflict with other trips ({other_trips}) on {conflict_days}
        ''').print()

    residual_days = node.days.difference(union_cases)
    if residual_days:
        if edge_type is simplify_graph.EdgeType.OUT:
            node.sink_node.days = node.sink_node.days.union(residual_days)
            graph.sinks.add(node.sink_node)
        else:
            node.source_node.days = node.source_node.days.union(residual_days)
            graph.sources.add(node.source_node)
